# ❔ 질문

Escaping Closure에 대해 설명하시오

<br />

# ✏️ 작성자
- [제리, 아리](#제리-아리)
- [고사리, 줄라이](#고사리-줄라이)
<br />

---

# 제리, 아리

## Escaping Closure에 대해 설명하시오

```swift
class ViewModel {
    var completionhandler: (() -> Void)? = nil

    func fetchData(completion: @escaping () -> Void) {
        completionhandler = completion
    }
}
```

- 함수 밖에서 실행되는 클로저를 뜻합니다.
- 함수 안에서 정의된 클로저가 외부 변수들에 대한 접근을 허용할 때 사용하거나 함수간 실행순서를 고려하여 작성할 수 있습니다.
- Swift에서는 함수의 파라미터로 전달된 클로저는 기본적으로 **함수 내부 스코프 안에서만** 사용이 가능하지만 @escaping 이라는 키워드를 파라미터 이름의 콜론 뒤에 쓰면 탈출 클로저로 선언할 수 있습니다.

<br />
<br />

## escaping 클로저를 사용하는 경우를 말씀해주세요.

- 보통은 비동기 작업을 하기 위해서 클로저를 탈출 시킵니다.
    - 자주 사용하는 경우가 completion handler.
    - 예를 들어 네트워크 요청 작업이 있고 비동기적으로 이를 처리하고 이 처리가 끝난 후 동작하는 것을 completion handler에 선언해주는 것입니다.

<br />
<br />

## escaping 클로저임을 명시한 경우 주의해야할 점이 무엇인가요?

- 클로저 내부에서 해당 타입의 프로퍼티, 메소드, 서브스크립트 등에 접근하려면 self 키워드를 명시적으로 사용해야 합니다.
    - 이유는 escaping 클로저를 사용할 때는 접근할 수 있는 경우의 수가 많기 때문에 어디에 접근하는 것인지 명확해야하기 때문입니다.
    - self를 캡쳐하게 된다면 강한 참조 사이클이 생길 수 있으니 주의해서 사용해야 합니다.
- 또, class와 같은 참조 타입이 아닌, 구조체, 열거형과 같은 값타입에서는 mutating reference의 캡쳐를 허용하지 않기 때문에 self 사용이 불가능합니다.

<br />
<br />

## escaping 클로저를 사용할 때 강한 참조 사이클은 보통 언제 발생하나요?

- 클로저가 인스턴스의 프로퍼티일 때, 혹은 클로저의 값 획득 특성 때문에 발생합니다.
    - 클로저를 클래스 인스턴스의 프로퍼티로 할당하면 클로저의 참조가 할당됩니다.
- 이를 해결하기 위해서는 캡쳐리스트를 통해 weak 키워드를 사용해서 해결할 수 있습니다.

<br />
<br />

## 클로저 내부에서 self 프로퍼티를 여러번 호출하면 어떻게 될까요?

- 클로저 내부에서 self 프로퍼티를 여러번 호출하여 접근한다고 해도 참조 횟수는 한번만 증가합니다.
    - 예를 들어 클래스 내부 함수에서 escaping 클로저를 사용한다고 가정했을 때, self를 통해 여러 프로퍼티를 접근해도 참조 카운트는 1번만 증가합니다.
   
<br />
<br />

## escaping과 non escaping의 차이점은 무엇인가요?

- 가장 큰 차이는 메모리 적인 차이입니다.
    - non escaping의 경우 함수의 실행이 완료되면 메모리에서 할당해제 되지만, escaping의 경우 함수가 실행을 마친 후에도 메모리 어딘가에 남아있게 됩니다.
    - 만약 클로저 내부에 엄청 느린 로직이 있어서 객체가 죽는 시점보다 클로저 종료 시점이 더 느린 상황이 온다면, 객체가 죽어야하는데… 클로저 실행이 끝나기 전까지는 self가 죽지 않고 살아서, 메모리가 해제되지 않는다. 즉 메모리 누수가 발생하는 것이다.
    - 따라서 강한 참조 사이클이 발생하는 경우에는 꼭 weak 키워드로 약한 참조를 걸어 메모리 누수를 피할 수 있도록 해야 합니다.
    

<br />
<br />

## weak self는 언제 사용하나요?

- 순환 참조로 인한 메모리 누수를 벗어나기 위해 사용합니다.
- weak를 붙이게 되면 참조하고 있는 객체가 죽게되면, 클로저 자체를 실행하지 않고 사라집니다.

<br />
<br />

## unowned와 weak의 차이는 무엇일까요?

- weak와 unowned의 가장 큰 차이는 옵셔널의 유무입니다.
- weak 속성을 사용하는 객체는 항상 optional로 객체가 사라지게 되면 nil값이 되고, unowned의 경우는 nil이 될수없어 객체가 사라지게 되면 댕글린 포인터만 남게 되는데 이 사라진 객체를 참조하게 되면 crash될 수 있습니다.
- 따라서 unowned는 사라지지 않는 것이 보장된 객체에만 설정하여야 합니다.

<br />
<br />
<br />

---

# 고사리, 줄라이

## 클로저에 대해 설명해주세요

클로저란 코드블럭이자 1급 시민입니다. 1급 시민이란 다음 세 가지 조건을 만족하는 타입을 의미합니다.

1. 변수에 저장이 가능한가?
2. 매개변수로 전달이 가능한가?
3. 리턴값으로 사용이 가능한가?

<br />
<br />

## 탈출 클로저는 무엇이며, 클로저와 탈출 클로저는 각각 어떤 경우에 사용하나요?

클로저는 해당 클로저의 할 일을 다른 객체에서 정의해주고 싶을 때 사용할 수 있는데, 예시 코드는 아래와 같습니다.

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
```

이때 파라미터로 전달되는 클로저의 앞에 `@escaping` 이 붙는 것을 볼 수 있습니다. 이렇듯, `함수 외부에 저장`되거나 `함수 밖(함수가 끝나고) 실행`되고자 하는 클로저는 파라미터 타입 앞에 해당 attribute를 붙여주어야 합니다.

<br />
<br />

## 참조타입인 클로저를 사용할 때 주의할 점은 무엇일까요?

본래 swift 3 이후부터, 함수의 인자로 들어오는 클로저는 함수 내부에서만 사용할 수 있습니다. 그러나 위와 같이 클로저 타입 앞에 `@escaping` 을 붙이면 escaping closure로 바뀌게 되며, (함수 실행이 끝난 시점에도) 외부에서 실행이 가능해집니다.

값 캡쳐가 돼서 deinit이 안됩니다. 

<br />
<br />

## 그것에 대한 해결 방법으로는 무엇이 있을까요?

클로저는 값을 캡쳐하는데, escaping closure같은 경우에는 외부에서 사용됨을 가정하고 사용하는 것이라 

내부의 프로퍼티나 self를 사용한다면 캡쳐리스트 안에 이를 넣어 캡쳐를 방지해야 합니다.
